# Copyright 2016 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This test checks that thread, select-frame, frame or inferior selection
# events are properly sent to all uis.
#
# This test considers the case where console and mi are two different uis
# and mi is created with the new-ui command.
#
# It also considers the case where the console commands are sent directly in
# the mi channel as described in PR 20487.
#
# It does so by starting 2 inferiors with 3 threads each.
# Thread 1 is the main thread starting the others.
# Thread 2 is stopped in non-stop mode.
# Thread 3 is the thread used for testing, in non-stop mode this thread is running.

# The test setup in all-stop mode is:
#
#   thread 1.1, stopped in main/sleep
#   thread 1.2, stopped in child_sub_function
#   thread 1.3, stopped in child_sub_function
#   thread 2.1, stopped in main/sleep
#   thread 2.2, stopped in child_sub_function
#   thread 2.3, stopped in child_sub_function
#
# And in non-stop mode:
#
#   thread 1.1, running
#   thread 1.2, stopped in child_sub_function
#   thread 1.3, running
#   thread 2.1, running
#   thread 2.2, stopped in child_sub_function
#   thread 2.3, running

load_lib mi-support.exp

standard_testfile

# Multiple inferiors are needed, therefore only native gdb and extended
# gdbserver modes are supported.
if [use_gdb_stub] {
    untested ${testfile}.exp
    return
}

set compile_options "debug pthreads"
if {[build_executable $testfile.exp $testfile ${srcfile} ${compile_options}] == -1} {
    untested "failed to compile $testfile"
    return -1
}

set main_bp_line [gdb_get_line_number "main break line"]
set thread_loop_line [gdb_get_line_number "thread loop line"]
set thread_caller_line [gdb_get_line_number "thread caller line"]

# Call PROCNAME with the given arguments, inside a with_test_prefix $procname
# block.

proc with_test_prefix_procname { procname args } {
    with_test_prefix $procname {
	$procname {*}$args
    }
}

# Make a regular expression to match the "thread selected" event for CLI.
#
# MODE can be either "all-stop" or "non-stop", indicating which one is currently
#   in use.
# INF is the inferior number we are expecting GDB to switch to, or -1 if we are
#   not expecting GDB to announce an inferior switch.
# THREAD is the thread number we are expecting GDB to switch to, or -1 if we are
#   not expecting GDB to announce a thread switch.
# FRAME is the frame number we are expecting GDB to switch to, or -1 if we are
#   not expecting GDB to announce a frame switch.  See the FRAME_RE variable for
#   details.
# If LINEEND is 1, expect and end of line at the end of the regular expression.

proc make_cli_re {mode inf thread frame lineend} {
    global srcfile
    global thread_caller_line thread_loop_line
    
    set inf_re "\\\[Switching to inferior $inf.*\\\]"
    set all_stop_thread_re "\\\[Switching to thread [string_to_regexp $thread].*\\\]"
    set frame_re(0) "#0.*child_sub_function.*$srcfile:$thread_loop_line\[\r\n\]+.*thread loop line \\\*/"
    set frame_re(1) "#1.*child_function \\\(args=0x0\\\) at .*$srcfile:$thread_caller_line\[\r\n\]+$thread_caller_line.*/\\\* thread caller line \\\*/"
    # Special frame for main threads.
    set frame_re(2) "#0.*"
    set end "\r\n"

    set cli_re ""

    if {$inf != -1} {
	append cli_re $inf_re
    }

    if {$thread != "-1"} {
	if {$inf != -1} {
	    append cli_re "\[\r\n\]+"
	}
	set thread_re $all_stop_thread_re
	
	if { $mode == "non-stop" && ($thread == "1.3" || $thread == "2.3")} {
	    set thread_re "$thread_re\\\(running\\\)"
	}

	append cli_re $thread_re
    }

    if {$frame != -1} {
	if {$thread != -1} {
	    append cli_re "\[\r\n\]+"
	}
	append cli_re $frame_re($frame)
    }

    if {$lineend == 1} {
	append cli_re $end
    }
    
    if {[string length "$cli_re"] == 0} {
	puts "AAAAAAAAAAAAAAAAAAAAAH"
    }

    return $cli_re
}

# Make a regular expression to match the "thread selected" event for MI.
#
# MODE can be either "all-stop" or "non-stop", indicating which one is currently
#   in use.
# THREAD is the thread number we are expecting GDB to switch to, or -1 if we are
#   not expecting GDB to announce a thread switch.
# FRAME is the frame number we are expecting GDB to switch to, or -1 if we are
#   not expecting GDB to announce a frame switch.  See the FRAME_RE variable for
#   details.
# If LINEEND is 1, expect and end of line at the end of the regular expression.

proc make_mi_re {mode thread event frame lineend} {
    global srcfile hex
    global thread_loop_line thread_caller_line

    set mi_re ""
    set thread_event_re "=thread-selected,id=\"$thread\""
    set thread_answer_re ".*\\^done,new-thread-id=\"$thread\""
    set frame_re(0) ",frame=\{level=\"0\",addr=\"$hex\",func=\"child_sub_function\",args=\\\[\\\],file=\".*$srcfile\",.*line=\"$thread_loop_line\"\}"
    set frame_re(1) ",frame=\{level=\"1\",addr=\"$hex\",func=\"child_function\",args=\\\[\{name=\"args\",value=\"0x0\"\}\\\],file=\".*$srcfile\",.*line=\"$thread_caller_line\"\}"
    #Special frame for main thread.
    set frame_re(2) ",frame=\{level=\"0\",addr=\"$hex\",func=\".*\",args=\\\[\\\],file=\".*\",fullname=\".*\",line=\".*\"\}"
    set end "\r\n"

    if {$thread != "-1"} {
	if {$event == 1} {
	    append mi_re $thread_event_re
	} elseif {$event == 0} {
	    append mi_re $thread_answer_re
	}
    }

    if {$frame != -1} {
	append mi_re $frame_re($frame)
    }

    if {$lineend == 1} {
	append mi_re $end
    }
    
    if {[string length "$mi_re"] == 0} {
	puts "AAAAAAAAAAAAAAAAAAAAAH"
    }

    return $mi_re
}

# Make a regular expression to match the "thread selected" event for CLI-in-MI.
#
# COMMAND is the CLI command that was sent to GDB, which will be output in the
#   console output stream.
# MODE can be either "all-stop" or "non-stop", indicating which one is currently
#   in use.
# INF is the inferior number we are expecting GDB to switch to, or -1 if we are
#   not expecting GDB to announce an inferior switch.
# CLI_THREAD is the thread number as seen in the CLI (inferior-qualified) we are
#   expecting GDB to switch to, or -1 if we are not expecting GDB to announce a
#   thread switch.
# MI_THREAD is the thread number as seen in the MI (global number) we are
#   expecting GDB to switch to, or -1 if we are not expecting GDB to announce a
#   thread switch.
# FRAME is the frame number we are expecting GDB to switch to, or -1 if we are
#   not expecting GDB to announce a frame switch.  See the FRAME_RE variable for
#   details.
# If LINEEND is 1, expect and end of line at the end of the regular expression.

proc make_cli_in_mi_re {command mode inf cli_thread mi_thread event frame lineend} {
    global srcfile bp_lineno caller_lineno

    set cli_in_mi_re ".*$command.*\[\r\n\]+"
    set frame_re(0) "~\"#0.*child_sub_function.*$srcfile:$bp_lineno\\\\n.*set break here \\\*/\\\\n\"\[\r\n\]+"
    set frame_re(1) "~\"#1.*child_function \\\(args=0x0\\\) at .*$srcfile:$caller_lineno\\\\n\"\[\r\n\]+~\"$caller_lineno.*caller \\\*/\\\\n\"\[\r\n\]+"
    set frame_re(2) "~\"#0.*\\\\n\"\[\r\n\]+"

    if {$inf != -1} {
	append cli_in_mi_re "~\""
	append cli_in_mi_re [make_cli_re $mode $inf "-1" -1 0]
	append cli_in_mi_re "\\\\n\"\[\r\n\]+"
    }

    if {$cli_thread != "-1"} {
	append cli_in_mi_re "~\""
	append cli_in_mi_re [make_cli_re $mode -1 $cli_thread -1 0]
	append cli_in_mi_re "\\\\n\"\[\r\n\]+"
    }

    if {$mode == "all-stop"} {
	append cli_in_mi_re $frame_re($frame)
    }

    if {$event != -1} {
	append cli_in_mi_re [make_mi_re $mode $mi_thread $event $frame $lineend]
    }
    append cli_in_mi_re "\[\r\n\]+\\^done"

    return $cli_in_mi_re
}

# Continue to the breakpoint indicating the start position of the threads.

proc test_continue_to_start { mode inf } {
    global gdb_prompt gdb_spawn_id gdb_main_spawn_id
    
    if { $gdb_spawn_id != $gdb_main_spawn_id } {
	unresolved "This should not happen."
    }
    
    with_test_prefix "inferior $inf" { with_spawn_id $gdb_main_spawn_id {
	gdb_continue_to_breakpoint "main breakpoint"
	
	if { $mode == "non-stop" } {
	    gdb_test "thread $inf.2" ".*" "switch to thread $inf.2"
	    
	    send_gdb "interrupt\n"
	    gdb_expect {
		-re "Thread.*2.*stopped" {
		    pass "interrupt thread $inf.2"
		}
	    }
	    #gdb_test "interrupt" "" "interrupt thread $inf.2"
	}
	#if {$mode == "all-stop" || $mode == "non-stop"} {
	#    
	#} else {
	#    set test "first continue"
        #
	#    gdb_test_multiple "continue&" $test {
	#	-re "Continuing\\.\[\r\n\]+$gdb_prompt " {
	#	    pass $test
	#	}
	#    }
        #
	#    # Wait until we've hit the breakpoint for the 2 threads.
	#    for {set i 1} { $i <= 2 } { incr i } {
	#	set test "thread $i started"
	#	gdb_test_multiple "" $test {
	#	    -re "hit Breakpoint" {
	#		# The prompt was already matched in the "continue &"
	#		# test above.  We're now consuming asynchronous output
	#		# that comes after the prompt.
	#		pass $test
	#	    }
	#	}
	#    }
	#    # Switch to the test thread.
	#    if {$inf == 1} {
	#	gdb_test "thread 3" [make_cli_re "all-stop" -1 "3" 0 -1] "Switch to test thread"
	#    } else {
	#	gdb_test "thread 2.3" [make_cli_re "all-stop" -1 "2\\.3" 0 -1] "Switch to test thread"
	#    }
	#    
	#    # Leave thread 3 running.
	#    gdb_test "continue&" "Continuing\\." "second continue"
	#}
    }
}
}

# Test context setup.

proc test_setup { mode } {
    global srcfile srcdir subdir testfile
    global gdb_main_spawn_id mi_spawn_id
    global decimal binfile main_bp_line
    global GDBFLAGS

    mi_gdb_exit

    save_vars { GDBFLAGS } {
	if {$mode == "non-stop"} {
	    set GDBFLAGS [concat $GDBFLAGS " -ex \"set non-stop 1\""]
	}

	if {[mi_gdb_start "separate-mi-tty"] != 0} {
	    return
	}
    }

    mi_delete_breakpoints
    mi_gdb_reinitialize_dir $srcdir/$subdir
    mi_gdb_load $binfile

    if {[mi_runto main] < 0} {
	fail "Can't run to main"
	return
    }

    with_spawn_id $gdb_main_spawn_id {
	gdb_test "break $srcfile:$main_bp_line" \
	    "Breakpoint $decimal .*$srcfile, line $main_bp_line\\\." \
	    "set breakpoint"

	test_continue_to_start $mode 1

	# Add a second inferior to test inferior selection.
	gdb_test "add-inferior" "Added inferior 2" "Add inferior 2"
	gdb_test "inferior 2" ".*" "switch to inferior 2"
	gdb_load ${binfile}
	gdb_test "start" "Temporary breakpoint.*Starting program.*"
	test_continue_to_start $mode 2
	gdb_test "inferior 1" ".*" "switch back to inferior 1"
    }
}

# Reset the selection to frame #0 of thread THREAD.

proc reset_selection { thread } {
    global gdb_main_spawn_id

    with_spawn_id $gdb_main_spawn_id {
	gdb_test "thread $thread" ".*" "reset selection to thread $thread"
	gdb_test "frame 0" ".*" "reset selection to frame 0"
    }
}

# Flush Expect's internal buffers for both CLI and MI.
#
# The idea here is to send a command, and to consume all the characters that we
# expect that command to output, including the following prompt.  Using gdb_test
# and mi_gdb_test should do that.

proc flush_all_the_things { } {
    global gdb_main_spawn_id mi_spawn_id
    
    with_spawn_id $gdb_main_spawn_id {
	gdb_test "print 444" "= 444" "flush cli"
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test "555-data-evaluate-expression 666" ".*done,value=\"666\"" "flush mi"
    }
}

# Run a command on the current spawn id, to confirm that no output is pending
# in Expect's internal buffer.  This is used to ensure that nothing was output
# on the spawn id since the last test.
#
# The key here is that the regexes use start-of-buffer anchors (^), ensuring
# that they match the entire buffer, confirming that there was nothing in it
# before.

proc ensure_no_output { test } {
    global gdb_spawn_id gdb_main_spawn_id mi_spawn_id
    global decimal

    if { $gdb_spawn_id == $gdb_main_spawn_id } {
	# CLI
	gdb_test "print 666" \
		 "^print 666\r\n\\\$$decimal = 666" \
		 "$test, ensure no output cli"
    } elseif { $gdb_spawn_id == $mi_spawn_id } {
	# MI
	mi_gdb_test "777-data-evaluate-expression 888" \
		    "^777-data-evaluate-expression 888\r\n777\\^done,value=\"888\"" \
		    "$test, ensure no output mi"
    } else {
	unresolved "This shouldn't happen."
    }
}

proc match_re_or_ensure_not_output { re test } {
    if { $re != "" } {
	gdb_expect {
	    -re "$re" {
		pass $test
	    }
	    
	    default {
		fail $test
	    }
	}
    } else {
	ensure_no_output $test
    }
}

# Test selecting an inferior from CLI.

proc test_cli_select_inferior { mode } {
    global gdb_main_spawn_id mi_spawn_id
    
    reset_selection "1.1"

    set mi_re [make_mi_re $mode "4" 1 2 1]
    set cli_re [make_cli_re $mode 2 "2.1" 2 0]

    flush_all_the_things

    # Do the 'inferior' command.
    with_spawn_id $gdb_main_spawn_id {
	gdb_test "inferior 2" $cli_re "cli select inferior"
    }

    with_spawn_id $mi_spawn_id {
	match_re_or_ensure_not_output $mi_re "event on mi"
    }

    # Do the 'inferior' command on the currently selected inferior.  For now,
    # GDB naively re-outputs everything.
    with_spawn_id $gdb_main_spawn_id {
	gdb_test "inferior 2" $cli_re "cli select inferior again"
    }
    
    with_spawn_id $mi_spawn_id {
	match_re_or_ensure_not_output $mi_re "event on mi again"
    }
}

# Test thread selection from CLI.

proc test_cli_select_thread { mode } {
    global gdb_main_spawn_id mi_spawn_id

    reset_selection "1.1"
    flush_all_the_things

    with_test_prefix "thread 1.2" {
	# Do the 'thread' command to select a stopped thread.
	
	set mi_re [make_mi_re $mode "2" 1 0 1]
	set cli_re [make_cli_re $mode -1 "1.2" 0 0]
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "thread 1.2" $cli_re "select thread"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select thread, event on mi "
	}
	
	# Do the 'thread' command to select the same thread.  We shouldn't receive
	# an event on MI, since we won't actually switch thread.
	
	set mi_re ""
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "thread 1.2" $cli_re "select thread again"
	}

	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select thread, event on mi again"
	}
	
	# Try the 'thread' command without arguments.
	
	set cli_re "\\\[Current thread is 1\\.2.*\\\]"
	set mi_re ""
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "thread" $cli_re "thread without args"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "thread without args, event on mi"
	}
    }
    
    with_test_prefix "thread 1.3" {
	# Do the 'thread' command to select the third thread, stopped on all-stop,
	# running on non-stop.

	if { $mode == "all-stop" } {
	    set cli_re [make_cli_re $mode -1 "1.3" 0 0]
	    set mi_re [make_mi_re $mode "3" 1 0 1]
	} else {
	    set cli_re [make_cli_re $mode -1 "1.3" -1 0]
	    set mi_re [make_mi_re $mode "3" 1 -1 1]
	}

	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "thread 1.3" $cli_re "select thread"
	}

	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select thread, event on mi"
	}

	# Do the 'thread' command to select the third thread again.  Again, we
	# shouldn't receive an event on MI.
	
	set mi_re ""
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "thread 1.3" $cli_re "select thread again"
	}

	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select thread again, event on mi"
	}
	
	# Try the 'thread' command without arguments.
	
	set cli_re "\\\[Current thread is 1\\.3.*\\\]"
	set mi_re ""
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "thread" $cli_re "thread without args"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "thread without args, event on mi"
	}
    }

    # Idea for the future: selecting a thread in a different inferior.  For now,
    # GDB doesn't show an inferior switch, but if it did, it would be a nice
    # place to test it.
}

# Test frame selection from CLI.

proc test_cli_select_frame { mode } {
    global gdb_main_spawn_id mi_spawn_id

    with_test_prefix "thread 1.2" {
	reset_selection "1.2"
	flush_all_the_things

	# Do the 'frame' command to select frame 1.

	set mi_re [make_mi_re $mode "2" 1 1 1]
	set cli_re [make_cli_re $mode -1 -1 1 0]

	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "frame 1" $cli_re "select frame 1"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select frame 1, event on mi"
	}
	
	# Do the 'frame' command to select the same frame.  This time we don't
	# expect an event on MI, since we won't actually change frame.
	
	set mi_re ""
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "frame 1" $cli_re "select frame 1 again"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select frame 1 again, event on mi"
	}
	
	# Do the 'frame' command without arguments.  We shouldn't see anything on MI.

	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "frame" $cli_re "frame without args"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "frame without args, event on mi"
	}
    }
    
    with_test_prefix "thread 1.3" {    
	# Now, try the 'frame' command on thread 3, which is running if we are in
	# non-stop mode.
	reset_selection "1.3"
	flush_all_the_things
	
	if {$mode == "all-stop"} {
	    set mi_re [make_mi_re $mode "3" 1 1 1]
	    set cli_re [make_cli_re $mode -1 -1 1 0]
	} elseif {$mode == "non-stop"} {
	    set mi_re ""
	    set cli_re "Selected thread is running\\."
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "frame 1" $cli_re "select frame 1"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select frame 1, event on mi"
	}
	
	# Do the 'frame' command without arguments.
	
	if { $mode == "non-stop" } {
	    set cli_re "No stack\\."
	}
	set mi_re ""

	with_spawn_id $gdb_main_spawn_id {
	    gdb_test "frame" $cli_re "frame without args"
	}
	
	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "frame without args, event on mi"
	}
    }
}

# Test frame selection from CLI with the select-frame command.

proc test_cli_select_select_frame { mode } {
    global gdb_main_spawn_id mi_spawn_id expect_out

    with_test_prefix "thread 1.2" {
	reset_selection "1.2"
	flush_all_the_things

	# Do the 'select-frame' command to select frame 1.

	set mi_re [make_mi_re $mode "2" 1 1 1]
	#set cli_re [make_cli_re $mode -1 -1 1 0]

	with_spawn_id $gdb_main_spawn_id {
	    gdb_test_no_output "select-frame 1" "select frame 1"
	}

	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select frame 1, event on mi"
	}
	
	# Do the 'select-frame' command to select the same frame.  This time we expect to
	# event on MI, since we won't actually change frame.
	
	set mi_re ""
	
	with_spawn_id $gdb_main_spawn_id {
	    gdb_test_no_output "select-frame 1" "select frame 1 again"
	}

	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select frame 1 again, event on mi"
	}
    }
    
    with_test_prefix "thread 1.3" {
	# Now, try the 'select-frame' command on thread 3, which is running if we are in
	# non-stop mode.
	reset_selection "1.3"
	flush_all_the_things
	
	if {$mode == "all-stop"} {
	    set mi_re [make_mi_re $mode "3" 1 1 1]
	} elseif {$mode == "non-stop"} {
	    set mi-re ""
	    set cli_re "Selected thread is running\\."
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    if { $mode == "all-stop" } {
		gdb_test_no_output "select-frame 1" "select frame 1"
	    } else {
		gdb_test "select-frame 1" $cli_re "select frame 1"
	    }
	}

	with_spawn_id $mi_spawn_id {
	    match_re_or_ensure_not_output $mi_re "select frame 1, event on mi"
	}
    }
}

# Test doing an up and then down command from cli.

proc test_cli_up_down {mode} {
    global gdb_main_spawn_id mi_spawn_id
    
    reset_selection "1.2"
    flush_all_the_things

    # Try doing an 'up'.

    set mi_re [make_mi_re $mode 2 1 1 1]
    set cli_re [make_cli_re $mode -1 -1 1 0]

    #if {$mode == "all-stop"} {
	#set cli_up_re 
	#set mi_up_re 
	#set cli_down_re [make_cli_re $mode -1 "-1" 0 0]
	#set mi_down_re [make_mi_re $mode "3" 1 0 1]
    #} elseif {$mode == "non-stop"} {
	#set cli_up_re "No stack\\."
	#set mi_up_re ""
	#set cli_down_re "No stack\\."
	#set mi_down_re ""
    #}

    with_spawn_id $gdb_main_spawn_id {
	gdb_test "up" $cli_re "frame up"
    }

    with_spawn_id $mi_spawn_id {
	match_re_or_ensure_not_output $mi_re "frame up, event on mi"
    }

    # Try doing a 'down'.

    set mi_re [make_mi_re $mode 2 1 0 1]
    set cli_re [make_cli_re $mode -1 -1 0 0]

    with_spawn_id $gdb_main_spawn_id {
	gdb_test "down" $cli_re "frame down"
    }

    with_spawn_id $mi_spawn_id {
	match_re_or_ensure_not_output $mi_re "frame down, event on mi"
    }
}



proc test_mi_select_thread_with_thread_group {mode} {

    # This only applies to non-stop mode.
    if {$mode == "all-stop"} {
	return;
    }
    global gdb_main_spawn_id mi_spawn_id

    set mi_re [make_mi_re "all-stop" "2" 0 0 0]
    set cli_re [make_cli_re "all-stop" -1 "1\\.2" 0 1]

    with_spawn_id $mi_spawn_id {
	mi_gdb_test "-thread-select --thread-group i1 2" $mi_re "mi select thread with thread group"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select thread with thread group"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }
}

# Test selecting a thread from MI.

proc test_mi_select_thread { mode } {
    global gdb_main_spawn_id mi_spawn_id

    reset_selection "1.1"
    flush_all_the_things

    with_test_prefix "thread 1.2" {
	# Do the '-thread-select' command to select a stopped thread.

	set mi_re [make_mi_re $mode "2" 0 0 0]
	set cli_re [make_cli_re $mode -1 "1.2" 0 1]

	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-thread-select 2" $mi_re "-thread-select"
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    match_re_or_ensure_not_output $cli_re "-thread-select, event on cli"
	}
	
	# Do the '-thread-select' command to select the same thread.  We
	# shouldn't receive an event on CLI, since we won't actually switch
	# thread.
	
	set cli_re ""
	
	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-thread-select 2" $mi_re "-thread-select again"
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    match_re_or_ensure_not_output $cli_re "-thread-select again, event on cli"
	}
    }
    
    with_test_prefix "thread 1.3" {
	# Do the '-thread-select' command to select the third thread, stopped on all-stop,
	# running on non-stop.

	if { $mode == "all-stop" } {
	    set mi_re [make_mi_re $mode "3" 0 0 0]
	    set cli_re [make_cli_re $mode -1 "1.3" 0 1]
	} else {
	    set mi_re [make_mi_re $mode "3" 0 -1 0]
	    set cli_re [make_cli_re $mode -1 "1.3" -1 1]
	}

	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-thread-select 3" $mi_re "-thread-select"
	}

	with_spawn_id $gdb_main_spawn_id {
	    match_re_or_ensure_not_output $cli_re "-thread-select, event on cli"
	}

	# Do the 'thread' command to select the third thread again.  Again, we
	# shouldn't receive an event on MI.
	
	set cli_re ""
	
	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-thread-select 3" $mi_re "-thread-select again"
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    match_re_or_ensure_not_output $cli_re "-thread-select again, event on cli"
	}
    }
    
    with_test_prefix "thread 1.2 with --thread" {
	# Test selecting a thread from MI with a --thread option.  This test
	# verifies that even if the thread GDB would switch to is the same has
	# the thread specified with --thread, an event is still sent to CLI.
	# In this case this is thread 1.2
	
	set mi_re [make_mi_re $mode "2" 0 0 0]
	set cli_re [make_cli_re $mode -1 "1.2" 0 1]

	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-thread-select --thread 2 2" $mi_re "-thread-select"
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    # TODO: it doesn't work as of now.
	    # match_re_or_ensure_not_output $cli_re "-thread-select, event on cli"
	}
    }

    # Idea for the future: selecting a thread in a different inferior.  For now,
    # GDB doesn't show an inferior switch, but if it did, it would be a nice
    # place to test it.
}

# Test selecting a frame from mi.

proc test_mi_select_frameasdas {mode frame} {
    global gdb_main_spawn_id mi_spawn_id

    if {$mode == "all-stop"} {
        set cli_re [make_cli_re $mode -1 "-1" $frame 1]
	set mi_re ".*\\^done"
    } elseif {$mode == "non-stop"} {
	# No output
	set cli_re ""
	set mi_re ".*\\^error,msg=\"Selected thread is running\\.\""
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test "-stack-select-frame $frame" $mi_re "mi select frame"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select frame"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }
}

proc test_mi_select_frame { mode } {
    global gdb_main_spawn_id mi_spawn_id

    with_test_prefix "thread 1.2" {
	reset_selection "1.2"
	flush_all_the_things

	# Do the '-stack-select-frame' command to select frame 1.

	set mi_re "\\^done"
	set cli_re [make_cli_re $mode -1 -1 1 1]

	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-stack-select-frame 1" $mi_re "-stack-select-frame"
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    match_re_or_ensure_not_output $cli_re "-stack-select-frame, event on mi"
	}

	# Do the '-stack-select-frame' command to select the same frame.  This time we don't
	# expect an event on CLI, since we won't actually change frame.
	
	set cli_re ""
	
	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-stack-select-frame 1" $mi_re "-stack-select-frame again"
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    match_re_or_ensure_not_output $cli_re "-stack-select-frame again, event on mi"
	}
    }
    
    with_test_prefix "thread 1.3" {    
	# Now, try the '-stack-select-frame' command on thread 3, which is
	# running if we are in non-stop mode.
	reset_selection "1.3"
	flush_all_the_things
	
	if {$mode == "all-stop"} {
	    set mi_re "\\^done"
	    set cli_re [make_cli_re $mode -1 -1 1 1]
	} elseif {$mode == "non-stop"} {
	    set cli_re ""
	    set mi_re ".*\\^error,msg=\"Selected thread is running\\.\""
	}
	
	with_spawn_id $mi_spawn_id {
	    mi_gdb_test "-stack-select-frame 1" $mi_re "-stack-select-frame"
	}
	
	with_spawn_id $gdb_main_spawn_id {
	    match_re_or_ensure_not_output $cli_re "-stack-select-frame, event on mi"
	}
    }
}

# Test selecting the same frame from mi.

proc test_mi_select_frame_twice {mode frame} {
    global gdb_main_spawn_id mi_spawn_id

    if {$mode == "all-stop"} {
        set cli_re [make_cli_re $mode -1 "-1" $frame 1]
	set mi_re ".*\\^done"
    } elseif {$mode == "non-stop"} {
	# No output
	set cli_re ""
	set mi_re ".*\\^error,msg=\"Selected thread is running\\.\""
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test "-stack-select-frame $frame" $mi_re "mi select frame twice, first call"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select frame twice, first call"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }

    if {$mode == "all-stop"} {
        set cli_re ""
	set mi_re ".*\\^done"
    } elseif {$mode == "non-stop"} {
	# No output
	set cli_re ""
	set mi_re ".*\\^error,msg=\"Selected thread is running\\.\""
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test "-stack-select-frame $frame" $mi_re "mi select frame twice, second call"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select frame twice, second call"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }

}

proc make_cli_in_mi_command { cli_in_mi_mode command } {
    if { $cli_in_mi_mode == "direct" } {
	return $command
    } elseif { $cli_in_mi_mode == "interpreter-exec" } {
	return "-interpreter-exec console \"$command\""
    } else {
	error "This should not happen."
    }
}

# Test selecting the inferior using a cli command in the mi channel.

proc test_cli_in_mi_select_inferior { mode cli_in_mi_mode } {
    global gdb_main_spawn_id mi_spawn_id
    
    reset_selection "1.1"
    flush_all_the_things
    
    set command [make_cli_in_mi_command $cli_in_mi_mode "inferior 2"]

    set mi_re [make_cli_in_mi_re [string_to_regexp $command] $mode 2 "2\\.1" "4" 1 2 0]
    set cli_re [make_cli_re $mode 2 "2\\.1" 2 1]

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select inferior"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select inferior"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }
}

# Test selecting the thread using a cli command in the mi channel.

proc test_cli_in_mi_select_thread {mode exec_mode} {
    global gdb_main_spawn_id mi_spawn_id

    if {$exec_mode == "interpreter-exec"} {
	set command "-interpreter-exec console \"thread 1.3\""
    } else {
	set command "thread 1.3"
    }

    set mi_re [make_cli_in_mi_re [string_to_regexp $command] $mode -1 "1\\.3" "3" 1 0 0]
    set cli_re [make_cli_re $mode -1 "1\\.3" 0 1]

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select thread"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select thread"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }
}

# Test selecting the frame using a cli command in the mi channel.

proc test_cli_in_mi_select_frame {mode exec_mode frame} {
    global gdb_main_spawn_id mi_spawn_id

    if {$exec_mode == "interpreter-exec"} {
	set command "-interpreter-exec console \"frame $frame\""
    } else {
	set command "frame $frame"
    }

    if {$mode == "all-stop"} {
	set cli_re [make_cli_re $mode -1 "-1" $frame 1]
	set mi_re [make_cli_in_mi_re [string_to_regexp $command] $mode -1 "-1" 3 1 $frame 0]
    } elseif {$mode == "non-stop"} {
	set cli_re ""
	set mi_re ".*\\^error,msg=\"Selected thread is running\\.\""
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select frame"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select frame"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }
}

# Test selecting the same thread using a cli command in the mi channel.

proc test_cli_in_mi_select_thread_twice {mode exec_mode} {
    global gdb_main_spawn_id mi_spawn_id

    if {$exec_mode == "interpreter-exec"} {
	set command "-interpreter-exec console \"thread 1.3\""
    } else {
	set command "thread 1.3"
    }

    set mi_re [make_cli_in_mi_re [string_to_regexp $command] $mode -1 "1\\.3" "3" 1 0 0]
    set cli_re [make_cli_re $mode -1 "1\\.3" 0 1]

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select thread twice, first call"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select thread twice, first call"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }

    set mi_re [make_cli_in_mi_re [string_to_regexp $command] $mode -1 "1\\.3" "3" -1 0 0]
    set cli_re ""

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select thread twice, second call"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select thread twice, second call"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }

}

# Test selecting the same frame using a cli command in the mi channel.

proc test_cli_in_mi_select_frame_twice {mode exec_mode frame} {
    global gdb_main_spawn_id mi_spawn_id

    if {$exec_mode == "interpreter-exec"} {
	set command "-interpreter-exec console \"frame $frame\""
    } else {
	set command "frame $frame"
    }

    if {$mode == "all-stop"} {
	set cli_re [make_cli_re $mode -1 "-1" $frame 1]
	set mi_re [make_cli_in_mi_re [string_to_regexp $command] $mode -1 "-1" 3 1 $frame 0]
    } elseif {$mode == "non-stop"} {
	set cli_re ""
	set mi_re ".*\\^error,msg=\"Selected thread is running\\.\""
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select frame twice, first call"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select frame twice, first call"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }

    if {$mode == "all-stop"} {
	set cli_re ""
	set mi_re [make_cli_in_mi_re [string_to_regexp $command] $mode -1 "-1" 3 -1 $frame 0]
    } elseif {$mode == "non-stop"} {
	set cli_re ""
	set mi_re ".*\\^error,msg=\"Selected thread is running\\.\""
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select frame twice, second call"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select frame twice, second call"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }

}

# Test printing the current thread using a cli command in the mi channel .

proc test_cli_in_mi_select_thread_no_args {mode exec_mode} {
    global gdb_main_spawn_id mi_spawn_id

    if {$exec_mode == "interpreter-exec"} {
	set command "-interpreter-exec console \"thread\""
    } else {
	set command "thread"
    }

    set mi_re ".*$command.*\[\r\n\]+"
    append mi_re "~\"\\\[Current thread is 1\\.3.*\\\]\\\\n\""
    append mi_re "\[\r\n\]+\\^done"

    set cli_re ""

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select thread no args"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select thread no args"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }
}

# Test printing the current frame using a cli command in the mi channel .

proc test_cli_in_mi_select_frame_no_args {mode exec_mode frame} {
    global gdb_main_spawn_id mi_spawn_id

    if {$exec_mode == "interpreter-exec"} {
	set command "-interpreter-exec console \"frame\""
    } else {
	set command "frame"
    }

    if {$mode == "all-stop"} {
	set cli_re ""
	set mi_re [make_cli_in_mi_re "frame" $mode -1 "-1" -1 -1 $frame 0]
    } elseif {$mode == "non-stop"} {
	set cli_re ""
	set mi_re ".*\\^error,msg=\"No stack\\.\""
    }

    with_spawn_id $mi_spawn_id {
	mi_gdb_test $command $mi_re "mi select frame"
    }

    with_spawn_id $gdb_main_spawn_id {
	set test "cli select frame"
	gdb_test_multiple "" $test {
	    -re $cli_re {
		pass $test
	    }
	}
    }
}

# Test all-stop and non-stop mode.

set timeout 200

foreach mode { "all-stop" "non-stop" } {
    with_test_prefix $mode {
	with_test_prefix_procname test_setup $mode

	# Test selecting inferior, thread and frame from CLI
	with_test_prefix_procname test_cli_select_inferior $mode
	with_test_prefix_procname test_cli_select_thread $mode
	with_test_prefix_procname test_cli_select_frame $mode
	with_test_prefix_procname test_cli_select_select_frame $mode
	with_test_prefix_procname test_cli_up_down $mode

	with_test_prefix_procname test_mi_select_thread $mode
	with_test_prefix_procname test_mi_select_frame $mode

	# Test with a direct command from cli in mi like "thread 1"
	# Or test with the interpreter-exec like -interpreter-exec "thread 1"
	foreach exec_mode {"cli in mi" "interpreter-exec"} {
	    with_test_prefix $exec_mode {
		    #with_test_prefix_procname test_cli_in_mi_select_inferior $mode $exec_mode
		#test_cli_in_mi_select_thread $mode $exec_mode
		#test_cli_in_mi_select_frame $mode $exec_mode 1
		#test_cli_in_mi_select_frame $mode $exec_mode 0
		## Reset thread/frame.
		#test_cli_in_mi_select_inferior $mode $exec_mode
		#test_cli_in_mi_select_thread_twice $mode $exec_mode
		#test_cli_in_mi_select_frame_twice $mode $exec_mode 1
		#test_cli_in_mi_select_frame $mode $exec_mode 0
		#test_cli_in_mi_select_thread_no_args $mode $exec_mode
		#test_cli_in_mi_select_frame_no_args $mode $exec_mode 0
	    }
	}
    }
}
